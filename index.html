<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interaktives Vollbild-Grid</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* CSS-Variablen-Definition im Root-Element */
        :root {
            --grid-size: 50px; /* Standardgröße der Grid-Zelle */
            --grid-columns: 10; 
            --grid-rows: 8;   
            --plus-size: 6px; /* Reduzierte Größe der Plus-Symbole */
            --dark-blue: #0A0A2A; /* Dunkler Hintergrund */
            
            /* NEUE FARBDEFINITIONEN (Vier Cyantöne) */
            --color-1: #00FFFF;  /* Aqua/Hell-Cyan */
            --color-2: #40E0D0;  /* Türkis/Medium-Cyan */
            --color-3: #00CED1;  /* DarkTurquoise/Dunkleres Cyan */
            --color-4: #20B2AA;  /* LightSeaGreen/Grünliches Cyan */

            --plus-color: #FFFFFF; /* Farbe der Plus-Symbole */
        }

        /* Vollbild- und Randabfallende Darstellung */
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            overflow: hidden; /* Verhindert Scrollbalken */
        }

        body {
            background-color: var(--dark-blue);
            font-family: 'Inter', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        /* Haupt-Grid-Container (nimmt den gesamten verfügbaren Platz ein) */
        .grid-wrapper {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        /* Das eigentliche Grid für die Rechtecke */
        .grid-container {
            position: relative; 
            width: 100%; 
            height: 100%; 
            z-index: 10; /* Rechtecke liegen VOR dem Haupt-Grid-Overlay */
            cursor: pointer; /* Visueller Hinweis, dass der Bereich klickbar ist */
        }

        /* Basisstil für alle Rechtecke */
        .rectangle {
            position: absolute; 
            opacity: 0.8;
            border-radius: 4px;
            /* Übergang für das flüssige Morphing über CSS-Transform */
            transition: 
                transform 500ms ease-in-out, 
                width 500ms ease-in-out,
                height 500ms ease-in-out,
                background-color 300ms ease-out; 
            transform-origin: top left;
        }

        /* Spezifische Klassen für die vier Farben */
        .color-1 { background-color: var(--color-1); }
        .color-2 { background-color: var(--color-2); }
        .color-3 { background-color: var(--color-3); }
        .color-4 { background-color: var(--color-4); }

        /* Container für die festen Plus-Symbole im HINTERGRUND */
        #plusOverlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%); 
            pointer-events: none; 
            z-index: 5; /* HINTERGRUND */
        }

        /* Container für die Plus-Symbole an den Eckpunkten (VORDERGRUND) */
        #plusFrontLayer {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%); 
            pointer-events: none; 
            z-index: 20; /* VORDERGRUND - über den Rechtecken */
        }

        /* Stil für das einzelne Plus-Symbol */
        .plus-icon {
            position: absolute;
            width: var(--plus-size);
            height: var(--plus-size);
            /* Erzeugt ein weißes/helles Plus-Symbol */
            background: 
                linear-gradient(to bottom, var(--plus-color), var(--plus-color)) center no-repeat,
                linear-gradient(to left, var(--plus-color), var(--plus-color)) center no-repeat;
            background-size: 1px 100%, 100% 1px; /* 1px dicke Linien für feinere Darstellung */
            transform: translate(-50%, -50%); /* Zentriert den Pluspunkt an seiner Position */
            transition: all 150ms ease-out; /* Übergang für die Positionierung, falls nötig */
        }

        /* Steuerungselemente unten links - NEUES DESIGN */
        .controls {
            position: fixed;
            bottom: 20px;
            left: 20px;
            z-index: 100;
            background-color: rgba(0, 0, 0, 0.75); /* Schwarz-Transparent */
            padding: 1.5rem; /* Etwas mehr Padding */
            border-radius: 0; /* Keine runden Ecken */
            box-shadow: none; /* Kein Schatten */
            width: 280px;
        }
        
        /* Styling für Slider und Text im Overlay */
        .controls label, .controls span {
            color: white !important; /* Weiße Typografie */
        }
        
        /* Slider Track Design (Tailwind classes for range input are inconsistent, so we use custom CSS) */
        input[type=range]::-webkit-slider-runnable-track {
            background: rgba(255, 255, 255, 0.2); /* Hellerer Track */
            height: 2px;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: var(--color-1); /* Cyan-Farbe für den Thumb */
            margin-top: -6px; /* Zentrieren des Thumbs auf dem Track */
        }
        /* Button Styling (wird entfernt, aber falls doch benötigt, wäre das das Styling) */
        .controls button {
            background-color: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 0;
        }
    </style>
</head>
<body>

    <!-- Vollbild-Wrapper für das Grid und die Plus-Symbole --><div class="grid-wrapper">
        <!-- 1. Grid-Container für die Rechtecke (wird von JS befüllt) --><div id="gridContainer" class="grid-container">
            <!-- Rechtecke werden hier eingefügt --></div>

        <!-- 2. Overlay für die Plus-Symbole im HINTERGRUND (alle Punkte) --><div id="plusOverlay">
            <!-- Alle Plus-Symbole als Hintergrundraster --></div>
        
        <!-- 3. NEU: Overlay für die Plus-Symbole an den Eckpunkten (VORDERGRUND) --><div id="plusFrontLayer">
            <!-- Nur die Eckpunkte der Rechtecke --></div>
    </div>

    <!-- Steuerungselemente unten links --><div class="controls">
        <label for="grid-slider" class="block text-sm font-medium mb-2">Rasterweite (px):</label>
        <div class="flex items-center">
            <input 
                type="range" 
                id="grid-slider" 
                min="20" 
                max="120" 
                value="50" 
                class="w-full h-2 bg-gray-300 appearance-none cursor-pointer range-lg transition duration-300"
            >
            <span id="grid-size-display" class="ml-3 w-10 text-right font-bold">50</span>
        </div>
        <!-- Zufällige Neugenerierung durch Klicken auf das Bild ersetzt, Button entfernt. 
        <button id="regenerate-button" class="mt-4 w-full px-4 py-2 text-sm font-semibold">
            Zufällige Neugenerierung
        </button>
        -->
    </div>

    <script>
        // Initial values
        let GRID_COLUMNS = 10;
        let GRID_ROWS = 8;
        const NUM_RECTANGLES = 4;
        let RECTANGLE_DATA = []; 
        const COLOR_CLASSES = ['color-1', 'color-2', 'color-3', 'color-4']; 
        let currentRectangleElements = []; 

        const gridWrapper = document.querySelector('.grid-wrapper');
        const gridContainer = document.getElementById('gridContainer');
        const plusOverlay = document.getElementById('plusOverlay');
        const plusFrontLayer = document.getElementById('plusFrontLayer'); 
        const slider = document.getElementById('grid-slider');
        const sizeDisplay = document.getElementById('grid-size-display');
        const root = document.documentElement;

        /**
         * Berechnet die optimale Anzahl von Spalten und Zeilen, um den Bildschirm auszufüllen.
         */
        function calculateGridDimensions(gridSize) {
            const wrapperWidth = gridWrapper.clientWidth;
            const wrapperHeight = gridWrapper.clientHeight;
            
            // Berechnet die maximal mögliche Anzahl von Spalten und Zeilen (90% des Viewports)
            GRID_COLUMNS = Math.floor((wrapperWidth * 0.9) / gridSize);
            GRID_ROWS = Math.floor((wrapperHeight * 0.9) / gridSize);
            
            // Behält mindestens ein 5x5-Raster bei
            GRID_COLUMNS = Math.max(5, GRID_COLUMNS);
            GRID_ROWS = Math.max(5, GRID_ROWS);

            const gridWidth = GRID_COLUMNS * gridSize;
            const gridHeight = GRID_ROWS * gridSize;
            
            // Setzt die Größe des Grid-Containers (wichtig für die Zentrierung des Overlays)
            gridContainer.style.width = `${gridWidth}px`;
            gridContainer.style.height = `${gridHeight}px`;

            return { gridWidth, gridHeight };
        }


        /**
         * Generiert genau 4 Rechtecke, die sich an einem zentralen Gitterpunkt treffen (Ecke berühren).
         * @param {number|null} clickCm - Der Spaltenindex (1-basiert) des Klickpunkts.
         * @param {number|null} clickRm - Der Zeilenindex (1-basiert) des Klickpunkts.
         */
        function generateRectangleData(clickCm = null, clickRm = null) {
            RECTANGLE_DATA = []; 

            // 1. Definiert den sicheren Bereich für den Mittelpunkt (Cm, Rm)
            // Cm/Rm muss mindestens 2 sein, um Platz für R1/R3 (links/oben) zu haben
            const minCol = 2; 
            const maxCol = GRID_COLUMNS; 
            const minRow = 2;
            const maxRow = GRID_ROWS;

            if (maxCol < minCol || maxRow < minRow) {
                console.error("Grid is too small to place the 4 meeting rectangles.");
                return;
            }

            let Cm, Rm;

            if (clickCm !== null && clickRm !== null) {
                // Verwende den Klickpunkt, klemme ihn aber an den sicheren Bereich.
                // Wir verwenden 'maxCol - 1' und 'maxRow - 1', da die Rechtecke rechts/unten (R2/R4) 
                // mindestens eine Spanne von 1 benötigen, was Cm/Rm bis maxCol-1 zulässt.
                Cm = Math.max(minCol, Math.min(clickCm, maxCol - 1)); 
                Rm = Math.max(minRow, Math.min(clickRm, maxRow - 1));
            } else {
                // Zufällige Initialisierung beim Start
                Cm = Math.floor(Math.random() * (maxCol - minCol - 1)) + minCol;
                Rm = Math.floor(Math.random() * (maxRow - minRow - 1)) + minRow;
            }

            const getRandomSpan = (max) => Math.floor(Math.random() * max) + 1; 

            // 2. Definiert die 4 Rechtecke relativ zu (Cm, Rm)
            
            // Rectangle 1: Top-Left Quadrant (color-1)
            const colSpan1 = getRandomSpan(Cm - 1); 
            const rowSpan1 = getRandomSpan(Rm - 1); 
            RECTANGLE_DATA.push({ id: 0, colStart: Cm - colSpan1, rowStart: Rm - rowSpan1, colSpan: colSpan1, rowSpan: rowSpan1, colorClass: COLOR_CLASSES[0] });

            // Rectangle 2: Top-Right Quadrant (color-2)
            const colSpan2 = getRandomSpan(GRID_COLUMNS - Cm); 
            const rowSpan2 = getRandomSpan(Rm - 1); 
            RECTANGLE_DATA.push({ id: 1, colStart: Cm, rowStart: Rm - rowSpan2, colSpan: colSpan2, rowSpan: rowSpan2, colorClass: COLOR_CLASSES[1] });

            // Rectangle 3: Bottom-Left Quadrant (color-3)
            const colSpan3 = getRandomSpan(Cm - 1); 
            const rowSpan3 = getRandomSpan(GRID_ROWS - Rm); 
            RECTANGLE_DATA.push({ id: 2, colStart: Cm - colSpan3, rowStart: Rm, colSpan: colSpan3, rowSpan: rowSpan3, colorClass: COLOR_CLASSES[2] });

            // Rectangle 4: Bottom-Right Quadrant (color-4)
            const colSpan4 = getRandomSpan(GRID_COLUMNS - Cm); 
            const rowSpan4 = getRandomSpan(GRID_ROWS - Rm); 
            RECTANGLE_DATA.push({ id: 3, colStart: Cm, rowStart: Rm, colSpan: colSpan4, rowSpan: rowSpan4, colorClass: COLOR_CLASSES[3] });
        }

        /**
         * Rendert die Rechtecke, indem absolute Pixelwerte und CSS Transform für flüssiges Morphing angewendet werden.
         */
        function renderRectangles(gridSize) {
            // Initiales Rendern: Erstellt die Rechteck-Elemente, falls sie nicht existieren
            if (currentRectangleElements.length === 0) {
                gridContainer.innerHTML = ''; 
                for (let i = 0; i < NUM_RECTANGLES; i++) {
                    const rect = document.createElement('div');
                    rect.classList.add('rectangle');
                    rect.style.width = '0px'; 
                    rect.style.height = '0px'; 
                    rect.style.transform = 'translate(0px, 0px)';

                    gridContainer.appendChild(rect);
                    currentRectangleElements.push(rect);
                }
            }

            // Aktualisiert die vorhandenen Rechteck-Elemente mit neuen Daten
            RECTANGLE_DATA.forEach((data, index) => {
                const rect = currentRectangleElements[index];
                if (rect) {
                    // Entfernt alte Farbklassen und fügt die neue hinzu
                    COLOR_CLASSES.forEach(cls => rect.classList.remove(cls));
                    rect.classList.add(data.colorClass); 
                    
                    // Berechnet absolute Pixelwerte basierend auf der aktuellen Grid-Größe
                    const pixelWidth = data.colSpan * gridSize;
                    const pixelHeight = data.rowSpan * gridSize;
                    const pixelX = (data.colStart - 1) * gridSize; 
                    const pixelY = (data.rowStart - 1) * gridSize; 

                    // Aktualisiert die Dimensionen
                    rect.style.width = `${pixelWidth}px`;
                    rect.style.height = `${pixelHeight}px`;

                    // Aktualisiert die Position über CSS transform für flüssiges Morphing
                    rect.style.transform = `translate(${pixelX}px, ${pixelY}px)`;
                }
            });
        }

        /**
         * Rendert die Plus-Symbole in 2 Schichten: Hintergrund und Vordergrund (Ecken).
         */
        function renderPlusIcons(gridWidth, gridHeight, gridSize) {
            plusOverlay.innerHTML = '';
            plusFrontLayer.innerHTML = ''; // Leert den Vordergrund-Layer
            
            // Setzt die Dimensionen der Overlay-Container für die Zentrierung
            plusOverlay.style.width = `${gridWidth + 1}px`; 
            plusOverlay.style.height = `${gridHeight + 1}px`; 
            plusFrontLayer.style.width = `${gridWidth + 1}px`; 
            plusFrontLayer.style.height = `${gridHeight + 1}px`; 

            // 1. Sammelt alle Eckpunkt-Koordinaten der 4 Rechtecke
            const cornerPoints = new Set(); // Verwendet ein Set, um doppelte Punkte zu vermeiden
            RECTANGLE_DATA.forEach(data => {
                const startX = (data.colStart - 1) * gridSize;
                const startY = (data.rowStart - 1) * gridSize;
                const endX = (data.colStart + data.colSpan - 1) * gridSize;
                const endY = (data.rowStart + data.rowSpan - 1) * gridSize;

                // Speichert die vier Ecken jedes Rechtecks
                cornerPoints.add(`${startX},${startY}`);
                cornerPoints.add(`${endX},${startY}`);
                cornerPoints.add(`${startX},${endY}`);
                cornerPoints.add(`${endX},${endY}`);
            });

            // 2. Iteriert über alle möglichen Grid-Intersektionen und erstellt die Plus-Symbole
            for (let r = 0; r <= GRID_ROWS; r++) {
                for (let c = 0; c <= GRID_COLUMNS; c++) {
                    const topPos = r * gridSize;
                    const leftPos = c * gridSize;
                    const key = `${leftPos},${topPos}`;

                    // Erstellt ein Plus-Symbol für den Hintergrund
                    const plusBackground = document.createElement('div');
                    plusBackground.classList.add('plus-icon');
                    // Reduzierte Deckkraft für Hintergrund-Symbole
                    plusBackground.style.opacity = '0.2'; 
                    plusBackground.style.top = `${topPos}px`;
                    plusBackground.style.left = `${leftPos}px`;
                    plusOverlay.appendChild(plusBackground);
                    
                    // Überprüft, ob dieser Punkt ein Eckpunkt ist
                    if (cornerPoints.has(key)) {
                        // Klonen des Plus-Symbols für den Vordergrund-Layer
                        const plusForeground = plusBackground.cloneNode();
                        // Volle Deckkraft für Vordergrund-Symbole
                        plusForeground.style.opacity = '1.0'; 
                        plusFrontLayer.appendChild(plusForeground);
                    }
                }
            }
        }


        /**
         * Aktualisiert die CSS-Variable für die Rastergröße und passt alle Elemente an.
         */
        function updateGrid(size) {
            const gridSize = parseInt(size);
            
            // 1. Aktualisiert die CSS-Variable in Echtzeit
            root.style.setProperty('--grid-size', gridSize + 'px');
            sizeDisplay.textContent = gridSize;

            // 2. Berechnet die neuen optimalen Grid-Dimensionen (Anzahl der Spalten/Zeilen)
            const { gridWidth, gridHeight } = calculateGridDimensions(gridSize);
            
            // 3. Rendert die Plus-Symbole in beiden Schichten
            renderPlusIcons(gridWidth, gridHeight, gridSize);
            
            // 4. Rendert/Aktualisiert die Rechtecke (jetzt mit neuer gridSize)
            renderRectangles(gridSize);
        }

        /**
         * Behandelt Klicks auf den Grid-Container, um den neuen Mittelpunkt zu setzen.
         */
        function handleImageClick(event) {
            const gridSize = parseInt(slider.value);
            const rect = gridContainer.getBoundingClientRect();
            
            // Koordinaten relativ zum Grid-Container (0,0 ist oben links des GridContainers)
            const relativeX = event.clientX - rect.left;
            const relativeY = event.clientY - rect.top;

            // Konvertiert in Grid-Schnittpunkt-Indizes (0-basiert)
            let cIndex = Math.round(relativeX / gridSize);
            let rIndex = Math.round(relativeY / gridSize);

            // Stellt sicher, dass der Klickpunkt mindestens 1 Zelle vom Rand entfernt ist,
            // da die Komposition 4 Quadranten benötigt (Cm, Rm muss mindestens 2 sein).
            cIndex = Math.max(1, Math.min(cIndex, GRID_COLUMNS - 1)); 
            rIndex = Math.max(1, Math.min(rIndex, GRID_ROWS - 1));

            // Die Logik verwendet 1-basierte Indizes:
            const newCm = cIndex + 1;
            const newRm = rIndex + 1;
            
            generateRectangleData(newCm, newRm);
            updateGrid(gridSize);
        }

        /**
         * Initialisiert die Anwendung und richtet Event-Listener ein.
         */
        function initialize() {
            // Event listener für den Slider (Echtzeit-Update ohne Throttling)
            slider.addEventListener('input', (event) => {
                updateGrid(event.target.value);
            });
            
            // Event listener für Klick in das Bild (neuer Mittelpunkt)
            gridContainer.addEventListener('click', handleImageClick);

            // ZUFÄLLIGE GENERIERUNG WIRD NUR BEIM ERSTEN START VERWENDET
            // Der Regenerieren-Button ist entfernt, daher keine weitere Logik nötig.
            const initialGridSize = slider.value;
            generateRectangleData(); // Erstmals Daten zufällig generieren
            updateGrid(initialGridSize); 

            // Passt das Grid bei Fenstergröße-Änderung an
            window.addEventListener('resize', () => {
                 updateGrid(slider.value);
            });
        }

        // Startet die Anwendung
        initialize();
    </script>
</body>
</html>
