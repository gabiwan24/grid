<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interaktives Vollbild-Grid</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- KORREKTUR: Tone.js Link auf robustere unpkg Quelle umgestellt -->
    <script src="https://unpkg.com/tone@14.8.52/build/Tone.js"></script>
    <style>
        /* CSS-Variablen-Definition im Root-Element */
        :root {
            --grid-size: 50px; /* Standardgröße der Grid-Zelle */
            --grid-columns: 10; 
            --grid-rows: 8;   
            --plus-size: 6px; /* Größe der Hintergrund-Symbole */
            --plus-size-highlighted: 10px; /* Grösse der VORDERGRUND-Symbole */
            --dark-blue: #0A0A2A; /* Dunkler Hintergrund */
            
            /* NEUE FARBDEFINITIONEN (Vier Cyantöne) */
            --color-1: #00FFFF;  /* Aqua/Hell-Cyan */
            --color-2: #40E0D0;  /* Türkis/Medium-Cyan */
            --color-3: #00CED1;  /* DarkTurquoise/Dunkleres Cyan */
            --color-4: #20B2AA;  /* LightSeaGreen/Grünliches Cyan */

            --plus-color: #FFFFFF; /* Farbe der Plus-Symbole */
        }

        /* Vollbild- und Randabfallende Darstellung */
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            overflow: hidden; /* Verhindert Scrollbalken */
        }

        body {
            background-color: var(--dark-blue);
            font-family: 'Inter', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        /* Haupt-Grid-Container (nimmt den gesamten verfügbaren Platz ein) */
        .grid-wrapper {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        /* Das eigentliche Grid für die Rechtecke */
        .grid-container {
            position: relative; 
            width: 100%; 
            height: 100%; 
            z-index: 10; /* Rechtecke liegen VOR dem Haupt-Grid-Overlay */
            cursor: pointer; /* Visueller Hinweis, dass der Bereich klickbar ist */
        }

        /* Basisstil für alle Rechtecke */
        .rectangle {
            position: absolute; 
            opacity: 1.0; /* Voll deckend (1.0) zur Vermeidung heller Ränder */
            border-radius: 0; /* Keine runden Ecken */
            /* Übergang für das flüssige Morphing über CSS-Transform */
            transition: 
                transform 500ms ease-in-out, 
                width 500ms ease-in-out,
                height 500ms ease-in-out,
                background-color 300ms ease-out; 
            transform-origin: top left;
        }

        /* Spezifische Klassen für die vier Farben */
        .color-1 { background-color: var(--color-1); }
        .color-2 { background-color: var(--color-2); }
        .color-3 { background-color: var(--color-3); }
        .color-4 { background-color: var(--color-4); }

        /* NEU: Canvas für das Hintergrundraster (alle Punkte, hohe Performance) */
        #plusCanvas {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%); 
            pointer-events: none; 
            z-index: 5; /* HINTERGRUND */
        }

        /* Container für die Plus-Symbole an den Eckpunkten (VORDERGRUND) */
        #plusFrontLayer {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%); 
            pointer-events: none; 
            z-index: 20; /* VORDERGRUND - über den Rechtecken */
        }

        /* Stil für das einzelne Plus-Symbol (nur für Vordergrund-Elemente verwendet) */
        .plus-icon {
            position: absolute;
            width: var(--plus-size-highlighted); 
            height: var(--plus-size-highlighted); 
            /* Erzeugt ein weißes/helles Plus-Symbol */
            background: 
                linear-gradient(to bottom, var(--plus-color), var(--plus-color)) center no-repeat,
                linear-gradient(to left, var(--plus-color), var(--plus-color)) center no-repeat;
            background-size: 2px 100%, 100% 2px; /* Liniendicke auf 2px (doppelt) erhöht */
            transform: translate(-50%, -50%); /* Zentriert den Pluspunkt an seiner Position */
            transition: all 150ms ease-out, opacity 50ms linear; /* Wichtig: Übergang für das Aufleuchten */
            opacity: 0.0; /* Startet VERBORGEN für sequentielle Aktivierung */
        }

        /* Steuerungselemente unten links - SCHWARZ-TRANSPARENTES RECHTECK */
        .controls {
            position: fixed;
            bottom: 20px;
            left: 20px;
            z-index: 100;
            background-color: rgba(0, 0, 0, 0.15); /* SCHWARZ-TRANSPARENT (0.15) */
            padding: 1.5rem; 
            border-radius: 0; /* Keine runden Ecken */
            box-shadow: none; 
            width: 280px;
        }
        
        /* Styling für Slider und Text im Overlay */
        .controls label, .controls span {
            color: white !important; /* Weiße Typografie */
        }
        
        /* Slider Track Design */
        input[type=range]::-webkit-slider-runnable-track {
            background: rgba(255, 255, 255, 0.2); 
            height: 2px;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: var(--color-1); 
            margin-top: -6px; 
        }
    </style>
</head>
<body>

    <!-- Vollbild-Wrapper für das Grid und die Plus-Symbole --><div class="grid-wrapper">
        <!-- 1. Grid-Container für die Rechtecke (wird von JS befüllt) --><div id="gridContainer" class="grid-container">
            <!-- Rechtecke werden hier eingefügt --></div>

        <!-- 2. Canvas für das Hintergrundraster (alle Punkte) --><canvas id="plusCanvas"></canvas>
        
        <!-- 3. Overlay für die Plus-Symbole an den Eckpunkten (VORDERGRUND) --><div id="plusFrontLayer">
            <!-- Nur die Eckpunkte der Rechtecke --></div>
    </div>

    <!-- Steuerungselemente unten links --><div class="controls">
        <label for="grid-slider" class="block text-sm font-medium mb-2">Rasterweite (px):</label>
        <div class="flex items-center">
            <input 
                type="range" 
                id="grid-slider" 
                min="20" 
                max="250" 
                value="50" 
                class="w-full h-2 bg-gray-300 appearance-none cursor-pointer range-lg transition duration-300"
            >
            <span id="grid-size-display" class="ml-3 w-10 text-right font-bold">50</span>
        </div>
    </div>

    <script>
        // Initial values
        let GRID_COLUMNS = 10;
        let GRID_ROWS = 8;
        const NUM_RECTANGLES = 4;
        let RECTANGLE_DATA = []; 
        const COLOR_CLASSES = ['color-1', 'color-2', 'color-3', 'color-4']; 
        let currentRectangleElements = []; 
        let currentMorphTimeout = null; 
        
        // Ein kleiner Überlappungswert, um Subpixel-Lücken zu vermeiden.
        const PIXEL_FIX = 1; 
        
        // Tone.js Synth für den Klick-Sound
        let synth;

        const gridWrapper = document.querySelector('.grid-wrapper');
        const gridContainer = document.getElementById('gridContainer');
        const plusCanvas = document.getElementById('plusCanvas'); 
        const plusFrontLayer = document.getElementById('plusFrontLayer'); 
        const slider = document.getElementById('grid-slider');
        const sizeDisplay = document.getElementById('grid-size-display');
        const root = document.documentElement;
        
        /**
         * Initialisiert den Tone.js Synth.
         */
        function initializeAudio() {
            if (typeof Tone === 'undefined') {
                console.error("Tone.js konnte nicht geladen werden.");
                return;
            }
            if (synth) return; 
            
            // Definiert einen einfachen, kurzen Percussion-Sound (NoiseSynth)
            synth = new Tone.NoiseSynth({
                noise: {
                    type: "white"
                },
                envelope: {
                    attack: 0.001,
                    decay: 0.05,
                    sustain: 0.001,
                    release: 0.05
                }
            }).toDestination();
            
            if (Tone.context.state !== 'running') {
                Tone.start();
            }
        }
        
        /**
         * Spielt den kurzen Klick-Sound ab.
         */
        function playClickSound() {
            if (synth) {
                synth.triggerAttackRelease(0.05); 
            }
        }


        /**
         * Berechnet die optimale Anzahl von Spalten und Zeilen, um den Bildschirm auszufüllen.
         */
        function calculateGridDimensions(gridSize) {
            const wrapperWidth = gridWrapper.clientWidth;
            const wrapperHeight = gridWrapper.clientHeight;
            
            GRID_COLUMNS = Math.floor((wrapperWidth * 0.9) / gridSize);
            GRID_ROWS = Math.floor((wrapperHeight * 0.9) / gridSize);
            
            GRID_COLUMNS = Math.max(5, GRID_COLUMNS);
            GRID_ROWS = Math.max(5, GRID_ROWS);

            const gridWidth = GRID_COLUMNS * gridSize;
            const gridHeight = GRID_ROWS * gridSize;
            
            gridContainer.style.width = `${gridWidth}px`;
            gridContainer.style.height = `${gridHeight}px`;

            return { gridWidth, gridHeight };
        }


        /**
         * Generiert genau 4 Rechtecke, die sich an einem zentralen Gitterpunkt treffen.
         */
        function generateRectangleData(clickCm = null, clickRm = null) {
            RECTANGLE_DATA = []; 

            const minCol = 2; 
            const maxCol = GRID_COLUMNS; 
            const minRow = 2;
            const maxRow = GRID_ROWS;

            if (maxCol < minCol || maxRow < minRow) {
                console.error("Grid is too small to place the 4 meeting rectangles.");
                return;
            }

            let Cm, Rm;

            if (clickCm !== null && clickRm !== null) {
                Cm = Math.max(minCol, Math.min(clickCm, maxCol - 1)); 
                Rm = Math.max(minRow, Math.min(clickRm, maxRow - 1));
            } else {
                // Zufällige Initialisierung beim Start
                Cm = Math.floor(Math.random() * (maxCol - minCol - 1)) + minCol;
                Rm = Math.floor(Math.random() * (maxRow - minRow - 1)) + minRow;
            }

            const getRandomSpan = (max) => Math.floor(Math.random() * max) + 1; 

            // Definiert die 4 Rechtecke relativ zu (Cm, Rm)
            
            // Rectangle 1: Top-Left Quadrant (color-1)
            const colSpan1 = getRandomSpan(Cm - 1); 
            const rowSpan1 = getRandomSpan(Rm - 1); 
            RECTANGLE_DATA.push({ id: 0, colStart: Cm - colSpan1, rowStart: Rm - rowSpan1, colSpan: colSpan1, rowSpan: rowSpan1, colorClass: COLOR_CLASSES[0] });

            // Rectangle 2: Top-Right Quadrant (color-2)
            const colSpan2 = getRandomSpan(GRID_COLUMNS - Cm); 
            const rowSpan2 = getRandomSpan(Rm - 1); 
            RECTANGLE_DATA.push({ id: 1, colStart: Cm, rowStart: Rm - rowSpan2, colSpan: colSpan2, rowSpan: rowSpan2, colorClass: COLOR_CLASSES[1] });

            // Rectangle 3: Bottom-Left Quadrant (color-3)
            const colSpan3 = getRandomSpan(Cm - 1); 
            const rowSpan3 = getRandomSpan(GRID_ROWS - Rm); 
            RECTANGLE_DATA.push({ id: 2, colStart: Cm - colSpan3, rowStart: Rm, colSpan: colSpan3, rowSpan: rowSpan3, colorClass: COLOR_CLASSES[2] });

            // Rectangle 4: Bottom-Right Quadrant (color-4)
            const colSpan4 = getRandomSpan(GRID_COLUMNS - Cm); 
            const rowSpan4 = getRandomSpan(GRID_ROWS - Rm); 
            RECTANGLE_DATA.push({ id: 3, colStart: Cm, rowStart: Rm, colSpan: colSpan4, rowSpan: rowSpan4, colorClass: COLOR_CLASSES[3] });
        }

        /**
         * Rendert die Rechtecke, indem absolute Pixelwerte und CSS Transform für flüssiges Morphing angewendet werden.
         */
        function renderRectangles(gridSize, immediate = false) {
            // Initiales Rendern: Erstellt die Rechteck-Elemente, falls sie nicht existieren
            if (currentRectangleElements.length === 0) {
                gridContainer.innerHTML = ''; 
                for (let i = 0; i < NUM_RECTANGLES; i++) {
                    const rect = document.createElement('div');
                    rect.classList.add('rectangle');
                    rect.style.width = '0px'; 
                    rect.style.height = '0px'; 
                    rect.style.transform = 'translate(0px, 0px)';

                    gridContainer.appendChild(rect);
                    currentRectangleElements.push(rect);
                }
                immediate = true; 
            }
            
            if (immediate) {
                currentRectangleElements.forEach(rect => rect.style.transition = 'none');
            }

            // Aktualisiert die vorhandenen Rechteck-Elemente mit neuen Daten
            RECTANGLE_DATA.forEach((data, index) => {
                const rect = currentRectangleElements[index];
                if (rect) {
                    COLOR_CLASSES.forEach(cls => rect.classList.remove(cls));
                    rect.classList.add(data.colorClass); 
                    
                    const pixelWidth = data.colSpan * gridSize;
                    const pixelHeight = data.rowSpan * gridSize;
                    let pixelX = (data.colStart - 1) * gridSize; 
                    let pixelY = (data.rowStart - 1) * gridSize; 
                    
                    // --- ANPASSUNG ZUR BEHEBUNG VON SUBPIXEL-LÜCKEN (Überlappung) ---
                    const fixedWidth = pixelWidth + PIXEL_FIX;
                    const fixedHeight = pixelHeight + PIXEL_FIX;
                    
                    // Korrigiert die Position, wenn das Rechteck nicht am oberen/linken Rand beginnt
                    if (data.colStart > 1) {
                        pixelX -= PIXEL_FIX;
                    }
                    if (data.rowStart > 1) {
                        pixelY -= PIXEL_FIX;
                    }

                    rect.style.width = `${fixedWidth}px`;
                    rect.style.height = `${fixedHeight}px`;

                    rect.style.transform = `translate(${pixelX}px, ${pixelY}px)`;
                }
            });
            
            // Reaktiviert Transitionen nach kurzer Verzögerung 
            if (immediate) {
                setTimeout(() => {
                    currentRectangleElements.forEach(rect => {
                        rect.style.transition = 'transform 500ms ease-in-out, width 500ms ease-in-out, height 500ms ease-in-out, background-color 300ms ease-out';
                    });
                }, 50);
            }
        }
        
        /**
         * Zeichnet das Hintergrundraster als Plus-Symbole auf das Canvas Element.
         */
        function renderCanvasGrid(gridWidth, gridHeight, gridSize) {
            const ctx = plusCanvas.getContext('2d');
            
            // Setzt die Dimensionen des Canvas
            plusCanvas.width = gridWidth + 1; 
            plusCanvas.height = gridHeight + 1;

            ctx.clearRect(0, 0, plusCanvas.width, plusCanvas.height);

            // Styling für Hintergrund-Symbole (weiß, transparent, dünn)
            ctx.fillStyle = 'rgba(255, 255, 255, 0.2)'; // 20% Deckkraft weiß
            const lineThickness = 1;
            const plusSize = parseFloat(root.style.getPropertyValue('--plus-size')) || 6;

            // Zeichnet alle Grid-Schnittpunkte
            for (let r = 0; r <= GRID_ROWS; r++) {
                for (let c = 0; c <= GRID_COLUMNS; c++) {
                    const centerX = c * gridSize;
                    const centerY = r * gridSize;

                    // Zeichnet horizontalen Strich
                    ctx.fillRect(centerX - plusSize / 2, centerY - lineThickness / 2, plusSize, lineThickness);
                    
                    // Zeichnet vertikalen Strich
                    ctx.fillRect(centerX - lineThickness / 2, centerY - plusSize / 2, lineThickness, plusSize);
                }
            }
        }

        /**
         * Rendert die Plus-Symbole an den Eckpunkten der Rechtecke im Vordergrund (DOM-Elemente).
         */
        function renderForegroundPlusIcons(gridWidth, gridHeight, gridSize) {
            plusFrontLayer.innerHTML = ''; 
            
            plusFrontLayer.style.width = `${gridWidth + 1}px`; 
            plusFrontLayer.style.height = `${gridHeight + 1}px`; 

            // 1. Sammelt alle Eckpunkt-Koordinaten
            const cornerPoints = new Set(); 
            if (RECTANGLE_DATA.length > 0) {
                 const Cm = RECTANGLE_DATA[1].colStart; 
                 const Rm = RECTANGLE_DATA[2].rowStart; 
                 
                 const pX = (Cm - 1) * gridSize;
                 const pY = (Rm - 1) * gridSize;
                 
                 cornerPoints.add(`${pX},${pY}`);
                 
                 // Die 16 Eckpunkte der 4 Rechtecke
                 RECTANGLE_DATA.forEach(data => {
                    const startX = (data.colStart - 1) * gridSize;
                    const startY = (data.rowStart - 1) * gridSize;
                    const endX = (data.colStart + data.colSpan - 1) * gridSize;
                    const endY = (data.rowStart + data.rowSpan - 1) * gridSize;

                    cornerPoints.add(`${startX},${startY}`);
                    cornerPoints.add(`${endX},${startY}`);
                    cornerPoints.add(`${startX},${endY}`);
                    cornerPoints.add(`${endX},${endY}`);
                });
            }

            // 2. Erstellt Plus-Symbole
            const createdIcons = [];
            cornerPoints.forEach(key => {
                const [leftPos, topPos] = key.split(',').map(Number);

                const plusForeground = document.createElement('div');
                plusForeground.classList.add('plus-icon');
                plusForeground.style.top = `${topPos}px`;
                plusForeground.style.left = `${leftPos}px`;
                plusFrontLayer.appendChild(plusForeground);
                createdIcons.push(plusForeground);
            });

            return createdIcons;
        }

        /**
         * Lässt die Icons nacheinander aufleuchten und spielt Sound ab.
         */
        function staggerLightUpIcons(icons) {
            icons.forEach((icon, index) => {
                setTimeout(() => {
                    icon.style.opacity = '1.0';
                    playClickSound(); 
                }, index * 50);
            });
        }


        /**
         * Aktualisiert die CSS-Variable für die Rastergröße und passt alle Elemente an.
         */
        function updateGrid(size) {
            const gridSize = parseInt(size);
            
            root.style.setProperty('--grid-size', gridSize + 'px');
            sizeDisplay.textContent = gridSize;

            const { gridWidth, gridHeight } = calculateGridDimensions(gridSize);
            
            renderCanvasGrid(gridWidth, gridHeight, gridSize);
            
            const icons = renderForegroundPlusIcons(gridWidth, gridHeight, gridSize);
            icons.forEach(icon => icon.style.opacity = '1.0');

            renderRectangles(gridSize, true); 
        }

        /**
         * Behandelt Klicks auf den Grid-Container, um den neuen Mittelpunkt zu setzen.
         */
        function handleImageClick(event) {
            initializeAudio(); 
            
            if (currentMorphTimeout !== null) return;
            
            const gridSize = parseInt(slider.value);
            const rect = gridContainer.getBoundingClientRect();
            
            const relativeX = event.clientX - rect.left;
            const relativeY = event.clientY - rect.top;

            let cIndex = Math.round(relativeX / gridSize);
            let rIndex = Math.round(relativeY / gridSize);

            cIndex = Math.max(1, Math.min(cIndex, GRID_COLUMNS - 1)); 
            rIndex = Math.max(1, Math.min(rIndex, GRID_ROWS - 1));

            const newCm = cIndex + 1;
            const newRm = rIndex + 1;
            
            // 1. Generiert NEUE Positionen, OHNE sie sofort anzuwenden
            generateRectangleData(newCm, newRm);
            
            // 2. Rendert die Vordergrund-Plus-Symbole SOFORT (noch unsichtbar)
            const { gridWidth, gridHeight } = calculateGridDimensions(gridSize);
            const newIcons = renderForegroundPlusIcons(gridWidth, gridHeight, gridSize);
            
            // 3. Startet das sequentielle Aufleuchten
            staggerLightUpIcons(newIcons);

            // 4. Startet den Morphing-Timeout (1000ms)
            currentMorphTimeout = setTimeout(() => {
                renderRectangles(gridSize); 
                currentMorphTimeout = null; 
            }, 1000); // 1 Sekunde Verzögerung
        }

        /**
         * Initialisiert die Anwendung und richtet Event-Listener ein.
         */
        function initialize() {
            // Event listener für den Slider (Echtzeit-Update ohne Throttling)
            slider.addEventListener('input', (event) => {
                 initializeAudio(); 
                
                if (currentMorphTimeout !== null) {
                    clearTimeout(currentMorphTimeout);
                    currentMorphTimeout = null;
                }
                updateGrid(event.target.value);
            });
            
            // Event listener für Klick in das Bild (neuer Mittelpunkt)
            gridContainer.addEventListener('click', handleImageClick);

            // Initiales Rendering beim Laden der Seite
            const initialGridSize = slider.value;
            generateRectangleData(); 
            updateGrid(initialGridSize); 

            // Passt das Grid bei Fenstergröße-Änderung an
            window.addEventListener('resize', () => {
                 updateGrid(slider.value);
            });
        }

        // Startet die Anwendung erst nach dem vollständigen Laden des Fensters.
        window.onload = initialize;
    </script>
</body>
</html>
