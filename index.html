<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Interaktives Grid - Pixel Radius</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        :root {
            --grid-size: 40px; /* Startwert auf 40 geändert */
            --grid-columns: 10; 
            --grid-rows: 8;   
            --plus-size: 6px; 
            --plus-size-highlighted: 10px; 
            --dark-blue: #0A0A2A; 
            
            --color-1: #00FFFF;  
            --color-2: #40E0D0;  
            --color-3: #00CED1;  
            --color-4: #20B2AA;  

            --plus-color: #FFFFFF; 
        }

        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            overflow: hidden;
            touch-action: none; 
        }

        body {
            background-color: var(--dark-blue);
            font-family: 'Inter', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            user-select: none; 
        }

        .grid-wrapper {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .grid-container {
            position: relative; 
            width: 100%; 
            height: 100%; 
            z-index: 10; 
            cursor: crosshair; 
        }

        .rectangle {
            position: absolute; 
            opacity: 1.0; 
            border-radius: 0; 
            transition: 
                transform 500ms ease-in-out, 
                width 500ms ease-in-out,
                height 500ms ease-in-out,
                background-color 300ms ease-out; 
            transform-origin: top left;
        }

        .color-1 { background-color: var(--color-1); }
        .color-2 { background-color: var(--color-2); }
        .color-3 { background-color: var(--color-3); }
        .color-4 { background-color: var(--color-4); }

        #plusCanvas {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%); 
            pointer-events: none; 
            z-index: 5; 
        }

        #plusFrontLayer {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%); 
            pointer-events: none; 
            z-index: 20; 
        }

        .plus-icon {
            position: absolute;
            width: var(--plus-size-highlighted); 
            height: var(--plus-size-highlighted); 
            background: 
                linear-gradient(to bottom, var(--plus-color), var(--plus-color)) center no-repeat,
                linear-gradient(to left, var(--plus-color), var(--plus-color)) center no-repeat;
            background-size: 2px 100%, 100% 2px; 
            transform: translate(-50%, -50%); 
            transition: all 150ms ease-out, opacity 50ms linear; 
            opacity: 0.0; 
        }

        #dragCircle {
            position: absolute;
            border: 1px dashed rgba(255, 255, 255, 0.6);
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 50%;
            pointer-events: none;
            z-index: 15;
            display: none; 
            transform: translate(-50%, -50%); 
        }

        #dragCenterDot {
            position: absolute;
            width: 6px;
            height: 6px;
            background-color: white;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 25; 
            display: none;
            box-shadow: 0 0 4px rgba(255, 255, 255, 0.8);
        }

        #dragLine {
            position: absolute;
            height: 1px; 
            background-color: rgba(255, 255, 255, 0.6);
            transform-origin: left center; 
            pointer-events: none;
            z-index: 25;
            display: none;
        }

        #statsDisplay {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 100;
            color: rgba(255, 255, 255, 0.8);
            font-family: 'Inter', monospace;
            font-size: 14px;
            pointer-events: none;
            display: none; 
            background-color: rgba(0, 0, 0, 0.3);
            padding: 8px 12px;
            border-radius: 4px;
        }

        .controls {
            position: fixed;
            bottom: 20px;
            left: 20px;
            z-index: 100;
            background-color: rgba(0, 0, 0, 0.15); 
            padding: 1.5rem; 
            border-radius: 0; 
            box-shadow: none; 
            width: 280px;
        }
        
        .controls label, .controls span {
            color: white !important; 
        }
        
        input[type=range]::-webkit-slider-runnable-track {
            background: rgba(255, 255, 255, 0.2); 
            height: 2px;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: var(--color-1); 
            margin-top: -6px; 
        }
    </style>
</head>
<body>

    <div class="grid-wrapper">
        <div id="gridContainer" class="grid-container"></div>
        <canvas id="plusCanvas"></canvas>
        <div id="plusFrontLayer"></div>
        
        <!-- Drag Visuals -->
        <div id="dragCircle"></div>
        <div id="dragCenterDot"></div>
        <div id="dragLine"></div>
    </div>

    <div id="statsDisplay">
        Radius: <span id="stat-radius" class="font-bold text-white">0px</span> | 
        Elemente: <span id="stat-plusses" class="font-bold text-white">0</span>
    </div>

    <div class="controls">
        <label for="grid-slider" class="block text-sm font-medium mb-2">Rasterweite (px):</label>
        <div class="flex items-center">
            <input 
                type="range" 
                id="grid-slider" 
                min="20" 
                max="250" 
                value="40" 
                class="w-full h-2 bg-gray-300 appearance-none cursor-pointer range-lg transition duration-300"
            >
            <span id="grid-size-display" class="ml-3 w-10 text-right font-bold">40</span>
        </div>
    </div>

    <script>
        // Globals
        let GRID_COLUMNS = 10;
        let GRID_ROWS = 8;
        const NUM_RECTANGLES = 4;
        let RECTANGLE_DATA = []; 
        const COLOR_CLASSES = ['color-1', 'color-2', 'color-3', 'color-4']; 
        let currentRectangleElements = []; 
        let currentMorphTimeout = null; 
        const PIXEL_FIX = 1; 

        // State für Drag-Geste
        let isDragging = false;
        let dragStartX = 0;
        let dragStartY = 0;
        let dragCenterCol = 0; 
        let dragCenterRow = 0;
        let currentRadiusPx = 0;
        let previewRectangleData = [];
        
        // Stabilisierung der Zufallswerte
        let fixedDragAngles = null; 
        let lastRenderedSignature = ''; 

        const gridWrapper = document.querySelector('.grid-wrapper');
        const gridContainer = document.getElementById('gridContainer');
        const plusCanvas = document.getElementById('plusCanvas'); 
        const plusFrontLayer = document.getElementById('plusFrontLayer'); 
        
        // Visual Feedback Elements
        const dragCircle = document.getElementById('dragCircle');
        const dragCenterDot = document.getElementById('dragCenterDot');
        const dragLine = document.getElementById('dragLine');
        
        // Stats Elements
        const statsDisplay = document.getElementById('statsDisplay');
        const statRadius = document.getElementById('stat-radius');
        const statPlusses = document.getElementById('stat-plusses');

        const slider = document.getElementById('grid-slider');
        const sizeDisplay = document.getElementById('grid-size-display');
        const root = document.documentElement;

        function calculateGridDimensions(gridSize) {
            const wrapperWidth = gridWrapper.clientWidth;
            const wrapperHeight = gridWrapper.clientHeight;
            
            GRID_COLUMNS = Math.floor((wrapperWidth * 0.9) / gridSize);
            GRID_ROWS = Math.floor((wrapperHeight * 0.9) / gridSize);
            
            GRID_COLUMNS = Math.max(5, GRID_COLUMNS);
            GRID_ROWS = Math.max(5, GRID_ROWS);

            const gridWidth = GRID_COLUMNS * gridSize;
            const gridHeight = GRID_ROWS * gridSize;
            
            gridContainer.style.width = `${gridWidth}px`;
            gridContainer.style.height = `${gridHeight}px`;

            return { gridWidth, gridHeight };
        }

        /**
         * Circle-Edge Algorithmus (Strict) mit stabilisierten Winkeln.
         */
        function generateRectangleData(centerCol, centerRow, radiusGridUnits = null, customAngles = null) {
            const resultData = []; 

            const minCol = 2; 
            const maxCol = GRID_COLUMNS; 
            const minRow = 2;
            const maxRow = GRID_ROWS;

            const Cm = Math.max(minCol, Math.min(centerCol, maxCol - 1)); 
            const Rm = Math.max(minRow, Math.min(centerRow, maxRow - 1));

            let effectiveRadius = radiusGridUnits;
            if (effectiveRadius === null) effectiveRadius = 0;

            const quadrants = [
                { id: 0, dx: -1, dy: -1, color: COLOR_CLASSES[0] }, 
                { id: 1, dx: 1, dy: -1, color: COLOR_CLASSES[1] }, 
                { id: 2, dx: -1, dy: 1, color: COLOR_CLASSES[2] }, 
                { id: 3, dx: 1, dy: 1, color: COLOR_CLASSES[3] } 
            ];

            quadrants.forEach((q, index) => {
                const angle = (customAngles && customAngles[index] !== undefined) 
                              ? customAngles[index] 
                              : Math.random() * (Math.PI / 2);
                
                let colSpan = Math.floor(Math.abs(Math.cos(angle) * effectiveRadius));
                let rowSpan = Math.floor(Math.abs(Math.sin(angle) * effectiveRadius));

                if (effectiveRadius === 2) {
                    colSpan = 1;
                    rowSpan = 1;
                }

                colSpan = Math.max(1, colSpan);
                rowSpan = Math.max(1, rowSpan);

                let colStart, rowStart;

                if (q.dx === -1) colStart = Cm - colSpan;
                else colStart = Cm;

                if (q.dy === -1) rowStart = Rm - rowSpan;
                else rowStart = Rm;

                // Clipping
                if (colStart < 1) {
                    const diff = 1 - colStart;
                    colStart = 1;
                    colSpan -= diff;
                }
                if (colStart + colSpan > GRID_COLUMNS + 1) {
                    colSpan = (GRID_COLUMNS + 1) - colStart;
                }

                if (rowStart < 1) {
                    const diff = 1 - rowStart;
                    rowStart = 1;
                    rowSpan -= diff;
                }
                if (rowStart + rowSpan > GRID_ROWS + 1) {
                    rowSpan = (GRID_ROWS + 1) - rowStart;
                }

                if (colSpan > 0 && rowSpan > 0) {
                    resultData.push({
                        id: q.id,
                        colStart: colStart,
                        rowStart: rowStart,
                        colSpan: colSpan,
                        rowSpan: rowSpan,
                        colorClass: q.color
                    });
                }
            });

            return resultData;
        }

        /**
         * Sammelt ALLE Gitterpunkte für die Statistik (Anzahl).
         */
        function getCoveredGridPoints(rectData, gridSize) {
            if (!rectData || rectData.length === 0) return new Set();
            
            const points = new Set();
            
            rectData.forEach(data => {
                const startColIndex = data.colStart - 1;
                const endColIndex = data.colStart - 1 + data.colSpan;
                
                const startRowIndex = data.rowStart - 1;
                const endRowIndex = data.rowStart - 1 + data.rowSpan;

                for (let c = startColIndex; c <= endColIndex; c++) {
                    for (let r = startRowIndex; r <= endRowIndex; r++) {
                        const pixelX = c * gridSize;
                        const pixelY = r * gridSize;
                        points.add(`${pixelX},${pixelY}`);
                    }
                }
            });
            
            return points;
        }

        function renderRectangles(gridSize, immediate = false) {
            if (currentRectangleElements.length === 0) {
                gridContainer.innerHTML = ''; 
                for (let i = 0; i < NUM_RECTANGLES; i++) {
                    const rect = document.createElement('div');
                    rect.classList.add('rectangle');
                    rect.style.width = '0px'; 
                    rect.style.height = '0px'; 
                    rect.style.transform = 'translate(0px, 0px)';
                    gridContainer.appendChild(rect);
                    currentRectangleElements.push(rect);
                }
                immediate = true; 
            }
            
            if (immediate) {
                currentRectangleElements.forEach(rect => {
                    rect.style.transition = 'none';
                    rect.style.transitionDelay = '0ms'; 
                });
            }

            RECTANGLE_DATA.forEach((data, index) => {
                const rect = currentRectangleElements[index];
                if (rect) {
                    COLOR_CLASSES.forEach(cls => rect.classList.remove(cls));
                    rect.classList.add(data.colorClass); 
                    
                    if (!immediate) {
                        rect.style.transitionDelay = `${index * 30}ms`;
                    } else {
                        rect.style.transitionDelay = '0ms';
                    }
                    
                    const pixelWidth = data.colSpan * gridSize;
                    const pixelHeight = data.rowSpan * gridSize;
                    let pixelX = (data.colStart - 1) * gridSize; 
                    let pixelY = (data.rowStart - 1) * gridSize; 
                    
                    const fixedWidth = pixelWidth + PIXEL_FIX;
                    const fixedHeight = pixelHeight + PIXEL_FIX;
                    
                    if (data.colStart > 1) pixelX -= PIXEL_FIX;
                    if (data.rowStart > 1) pixelY -= PIXEL_FIX;

                    rect.style.width = `${fixedWidth}px`;
                    rect.style.height = `${fixedHeight}px`;
                    rect.style.transform = `translate(${pixelX}px, ${pixelY}px)`;
                }
            });
            
            if (immediate) {
                setTimeout(() => {
                    currentRectangleElements.forEach(rect => {
                        rect.style.transition = 'transform 500ms ease-in-out, width 500ms ease-in-out, height 500ms ease-in-out, background-color 300ms ease-out';
                        rect.style.transitionDelay = '0ms'; 
                    });
                }, 50);
            } else {
                setTimeout(() => {
                    currentRectangleElements.forEach(rect => {
                        rect.style.transitionDelay = '0ms';
                    });
                }, 1000);
            }
        }
        
        function renderCanvasGrid(gridWidth, gridHeight, gridSize) {
            const ctx = plusCanvas.getContext('2d');
            plusCanvas.width = gridWidth + 1; 
            plusCanvas.height = gridHeight + 1;
            ctx.clearRect(0, 0, plusCanvas.width, plusCanvas.height);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
            const lineThickness = 1;
            const plusSize = parseFloat(root.style.getPropertyValue('--plus-size')) || 6;

            for (let r = 0; r <= GRID_ROWS; r++) {
                for (let c = 0; c <= GRID_COLUMNS; c++) {
                    const centerX = c * gridSize;
                    const centerY = r * gridSize;
                    ctx.fillRect(centerX - plusSize / 2, centerY - lineThickness / 2, plusSize, lineThickness);
                    ctx.fillRect(centerX - lineThickness / 2, centerY - plusSize / 2, lineThickness, plusSize);
                }
            }
        }

        function renderForegroundPlusIcons(gridWidth, gridHeight, gridSize, customData = null) {
            plusFrontLayer.innerHTML = ''; 
            plusFrontLayer.style.width = `${gridWidth + 1}px`; 
            plusFrontLayer.style.height = `${gridHeight + 1}px`; 

            const dataToUse = customData || RECTANGLE_DATA;
            if (dataToUse.length === 0) return [];

            const cornerPoints = new Set(); 
            dataToUse.forEach(data => {
                const startX = (data.colStart - 1) * gridSize;
                const startY = (data.rowStart - 1) * gridSize;
                const endX = (data.colStart + data.colSpan - 1) * gridSize;
                const endY = (data.rowStart + data.rowSpan - 1) * gridSize;
                
                cornerPoints.add(`${startX},${startY}`);
                cornerPoints.add(`${endX},${startY}`);
                cornerPoints.add(`${startX},${endY}`);
                cornerPoints.add(`${endX},${endY}`);
            });

            const createdIcons = [];
            cornerPoints.forEach(key => {
                const [leftPos, topPos] = key.split(',').map(Number);
                const plusForeground = document.createElement('div');
                plusForeground.classList.add('plus-icon');
                plusForeground.style.top = `${topPos}px`;
                plusForeground.style.left = `${leftPos}px`;
                
                if (customData) {
                    plusForeground.style.opacity = '1.0';
                }
                
                plusFrontLayer.appendChild(plusForeground);
                createdIcons.push(plusForeground);
            });

            return createdIcons;
        }

        function staggerLightUpIcons(icons) {
            icons.forEach((icon, index) => {
                setTimeout(() => {
                    icon.style.opacity = '1.0';
                }, index * 30);
            });
        }

        function updateGrid(size) {
            const gridSize = parseInt(size);
            root.style.setProperty('--grid-size', gridSize + 'px');
            sizeDisplay.textContent = gridSize;
            const { gridWidth, gridHeight } = calculateGridDimensions(gridSize);
            renderCanvasGrid(gridWidth, gridHeight, gridSize);
            const icons = renderForegroundPlusIcons(gridWidth, gridHeight, gridSize);
            icons.forEach(icon => icon.style.opacity = '1.0');
            renderRectangles(gridSize, true); 
        }

        // --- INTERAKTIONSHANDLER ---

        function getEventPos(e) {
            const rect = gridContainer.getBoundingClientRect();
            let clientX, clientY;
            
            if (e.touches && e.touches.length > 0) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }
            
            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }

        function handleStart(e) {
            if (currentMorphTimeout !== null) return;
            if(e.type === 'touchstart') e.preventDefault();

            const gridSize = parseInt(slider.value);
            const pos = getEventPos(e);

            let cIndex = Math.round(pos.x / gridSize);
            let rIndex = Math.round(pos.y / gridSize);
            
            cIndex = Math.max(1, Math.min(cIndex, GRID_COLUMNS - 1)); 
            rIndex = Math.max(1, Math.min(rIndex, GRID_ROWS - 1));

            dragCenterCol = cIndex + 1;
            dragCenterRow = rIndex + 1;

            dragStartX = cIndex * gridSize;
            dragStartY = rIndex * gridSize;

            isDragging = true;
            currentRadiusPx = 0;
            previewRectangleData = [];
            
            fixedDragAngles = [
                Math.random() * (Math.PI / 2),
                Math.random() * (Math.PI / 2),
                Math.random() * (Math.PI / 2),
                Math.random() * (Math.PI / 2)
            ];
            lastRenderedSignature = ''; 

            dragCircle.style.display = 'block';
            dragCircle.style.width = '0px';
            dragCircle.style.height = '0px';
            dragCircle.style.left = `${dragStartX}px`;
            dragCircle.style.top = `${dragStartY}px`;

            dragCenterDot.style.display = 'block';
            dragCenterDot.style.left = `${dragStartX}px`;
            dragCenterDot.style.top = `${dragStartY}px`;

            dragLine.style.display = 'block';
            dragLine.style.left = `${dragStartX}px`;
            dragLine.style.top = `${dragStartY}px`;
            dragLine.style.width = '0px';

            statsDisplay.style.display = 'block';
            statRadius.innerText = "0px";
            statPlusses.innerText = "0";
        }

        function handleMove(e) {
            if (!isDragging) return;
            if(e.type === 'touchmove') e.preventDefault();

            const pos = getEventPos(e);
            const gridSize = parseInt(slider.value);
            const { gridWidth, gridHeight } = calculateGridDimensions(gridSize);
            
            const dx = pos.x - dragStartX;
            const dy = pos.y - dragStartY;
            currentRadiusPx = Math.sqrt(dx*dx + dy*dy);

            const diameter = currentRadiusPx * 2;
            dragCircle.style.width = `${diameter}px`;
            dragCircle.style.height = `${diameter}px`;

            const angle = Math.atan2(dy, dx);
            dragLine.style.width = `${currentRadiusPx}px`;
            dragLine.style.transform = `rotate(${angle}rad)`;

            // --- STATS & LIVE PREVIEW ---
            const radiusInGridUnits = Math.floor(currentRadiusPx / gridSize);
            statRadius.innerText = Math.round(currentRadiusPx) + "px";

            if (radiusInGridUnits >= 2) {
                previewRectangleData = generateRectangleData(dragCenterCol, dragCenterRow, radiusInGridUnits, fixedDragAngles);
                
                const currentSignature = JSON.stringify(previewRectangleData);
                if (currentSignature !== lastRenderedSignature) {
                    
                    const coveredPoints = getCoveredGridPoints(previewRectangleData, gridSize);
                    statPlusses.innerText = coveredPoints.size;
                    statPlusses.style.color = "#fff"; 

                    renderForegroundPlusIcons(gridWidth, gridHeight, gridSize, previewRectangleData);
                    
                    lastRenderedSignature = currentSignature;
                }

            } else {
                statPlusses.innerText = "0";
                statPlusses.style.color = "#aaa"; 
                previewRectangleData = [];
                plusFrontLayer.innerHTML = ''; 
                lastRenderedSignature = '';
            }
        }

        function handleEnd(e) {
            if (!isDragging) return;
            isDragging = false;
            
            dragCircle.style.display = 'none';
            dragCenterDot.style.display = 'none';
            dragLine.style.display = 'none';

            const gridSize = parseInt(slider.value);
            
            if (!previewRectangleData || previewRectangleData.length === 0) {
                return; 
            }

            RECTANGLE_DATA = previewRectangleData;

            const { gridWidth, gridHeight } = calculateGridDimensions(gridSize);
            const newIcons = renderForegroundPlusIcons(gridWidth, gridHeight, gridSize);
            newIcons.forEach(icon => icon.style.opacity = '0.0');

            staggerLightUpIcons(newIcons);

            currentMorphTimeout = setTimeout(() => {
                renderRectangles(gridSize); 
                currentMorphTimeout = null; 
            }, 1000);
        }

        function initialize() {
            slider.addEventListener('input', (event) => {
                if (currentMorphTimeout !== null) {
                    clearTimeout(currentMorphTimeout);
                    currentMorphTimeout = null;
                }
                updateGrid(event.target.value);
            });
            
            gridContainer.addEventListener('mousedown', handleStart);
            window.addEventListener('mousemove', handleMove); 
            window.addEventListener('mouseup', handleEnd);

            gridContainer.addEventListener('touchstart', handleStart, {passive: false});
            window.addEventListener('touchmove', handleMove, {passive: false});
            window.addEventListener('touchend', handleEnd);

            const initialGridSize = slider.value;
            updateGrid(initialGridSize); 

            window.addEventListener('resize', () => {
                 updateGrid(slider.value);
            });
        }

        window.onload = initialize;
    </script>
</body>
</html>


